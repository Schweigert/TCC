 
\chapter{Desenvolvimento das arquiteturas propostas}
\label{cap5}



Após o levantamento e fichamento dos requisitos para execução dos experimentos sobre as arquiteturas \ac{mmorpg} Rudy, Salz e Willson, é notório a necessidade de exemplificar o funcionamento de tais arquiteturas.
%
Nesse sentido, o capítulo atual levanta as devidas considerações sobre o desenvolvimento prático das arquiteturas específicas a jogos \ac{mmorpg} utilisadas neste trabalho.


Durante todos os experimentos, o ambiente é composto pelo mesmo conjunto de computadores, utilizando as mesmas topologias.
%
Este tópico é abordado no capítulo atual com maior profundidade na Seção~\ref{sec:topologia}.

Além da padronização, componentes básicos não foram alterados para as arquiteturas, tais como o conjunto de computadores que hospedaram os bancos de dados e a arquitetura que armazenou as métricas para posterior análise.
%
O sistema de coleta de informações de recursos é abordado na Seção~\ref{sec:informacoes}.

A explicação técnica dos projetos estão organizadas da seguinte forma para cada serviço desenvolvido das arquiteturas:


\begin{enumerate}
    \item Linguagem de Programação e tecnologias: Enumera as linguagens de programação e quais módulos ou bibliotecas foram utilizados para o seu desenvolvimento.
    \item Protocolos Utilizados: Enumera protocolos utilizados pelos serviços. 
    \item Modelo de processamento: Enumera o seu modelo de processamento, podendo ser passivo as requisições do ecossistema ou ativamente processar dados da arquitetura.
\end{enumerate}

Ao final é levantado o funcionamento do cliente das arquiteturas Rudy (Subseção~\ref{rudy}), Salz (Subseção~\ref{salz}) e Willson (Subseção~\ref{willson}).
%
Nesta etapa é exibido o fluxo de mensagens a partir das ações realizadas pelo cliente.
%
Nesse sentido este capítulo abrange todos os aspéctos técnicos da aplicação, levando em consideração o seu fluxo de funcionamento e integração entre os microsserviços no ecossistema da arquitetura.


\section{Topologia da Rede}
\label{sec:topologia}

A topologia da rede seguiu o padrão proposto para a coleta de dados.
%
O principal objetivo desta topologia é segregar as instâncias na camada de rede, evitando interferências do orquestrador de microsserviços que é utilizado na etapa de implantação.
%
A segregação em sub-redes é importante visto que, a fim de otimizar o transporte de dados entre os serviços, tais orquestradores trocam mensagens na rede utilizando memória ou disco, visto que uma conexão pode ser realizada para o próprio hospedeiro.
%
Segregando em sub-redes, o orquestrador é forçado a realizar a conexão com as instâncias externas, forçando a utilização da pilha completa do protocolo \ac{tcp} e \ac{udp}, a qual são eventuais pontos de gargalo em tais arquiteturas.

Para gerenciar as sub-redes foi utilizado o gestor da Nuvem Tchê, orquestrada com o OpenStack~\footnote{OpenStack: \url{https://www.openstack.org/}}.
%
A topologia utilizada nos testes com as três arquiteturas podem ser visualizada na Figura~\ref{fig:topologia}.


\begin{figure}[htb!]
    \caption{Topologia da rede no gestor de redes do OpenStack.}
    \centering
    \begin{subfigure}{0.5\textwidth}
      \centering
      \includegraphics[width=.8\textwidth]{img/cap5/topology_graph.png}
      \caption{Grafo OpenStack do experimento.}
      \label{fig:topologia_a}
    \end{subfigure}%
    \begin{subfigure}{0.5\textwidth}
      \centering
      \includegraphics[width=.8\textwidth]{img/cap5/topology.png}
      \caption{Topologia da rede OpenStack.}
      \label{fig:topologia_b}
    \end{subfigure}
    \label{fig:topologia}

    Fonte: O próprio autor.
\end{figure}


A Figura~\ref{fig:topologia} mostra a disposição das instâncias em sub-redes exibindo-as em formato de árvore e em barras.
%
A visualização com formato árvore ajuda a compreender a conexão entre cada máquina do ambiente de testes.
%
Já a visualização em formato barra, exibe características técnicas como a divisão por \ac{ip} e nome da rede.
%
Ambos os gráficos são complementares para formar as características básicas da interconexão das sub-redes.

A Figura~\ref{fig:topologia} também exibe 8 instâncias utilizadas nos testes.
%
Cada instância pode ter configurações padrões de \ac{os}, \acs{vcpu}, memória.
%
Além disso, o OpenStack permite a criação rápida de réplicas de uma instância.
%
Dessa forma facilitando a configuração da rede final.
%
As características específicas das instâncias estão listadas na Tabela~\ref{tab:instancias}.

\begin{table}[htb!]
    \centering
    \caption{Instâncias das redes de teste}
    \label{tab:instancias}
    \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Nome                    & \ac{os}             &\acs{vcpu}& Memória & Rede ou IP   & Réplicas \\ \hline
        \textit{client\_*}      & Ubuntu Server 16.04 & 1        & 1 GB    & 192.168.2.*  & 5        \\ \hline
        \textit{game\_service}  & Ubuntu Server 16.04 & 4        & 8 GB    & 192.168.0.8  & 1        \\ \hline
        \textit{game\_database} & Ubuntu Server 16.04 & 1        & 1 GB    & 192.168.3.11 & 1        \\ \hline
        \textit{data\_analisys} & Ubuntu Server 16.04 & 4        & 4 GB    & 192.168.1.2  & 1        \\ \hline
    \end{tabular}

    Fonte: O próprio autor.
\end{table}

A Tabela~\ref{tab:instancias} enumera as máquinas virtuais utilizadas no experimento, descrevendo as suas principais características.
%
É utilizado as seguintes instâncias no experimento:

\begin{itemize}
    \item \textit{client\_*}: são responsáveis por executar os clientes a qual realizam o ataque de carga ao serviço.
    \item \textit{game\_service}: é responsável unicamente por executar os microsserviços das arquiteturas Rudy, Salz e/ou Willson.
    \item \textit{game\_database}: é responsável por executar o banco de dados Postgres e Redis, ambos utilizados em todas as arquiteturas.
    \item \textit{data\_analisys}: é responsável por executar o banco de métricas e o sistema de monitoramento.
\end{itemize}

Em especial, a categoria de instância \textit{client\_*}, a qual executa os clientes, foi escalada em 5 instâncias.
%
Este número foi definido com base em testes com a arquitetura Rudy, escalando máquinas virtuais dado a instância do serviço pré definido na Tabela~\ref{tab:instancias}.
%
O menor valor de instâncias \textit{client\_*} escaladas para alcançar o estresse da instância \textit{game\_service} foi 5.
%
Nesse sentido, será utilizado para todos os testes o valor de 5 instâncias para o ataque de carga de seriço.


A gestão das instâncias, dentro de cada sub-rede, foi automatizada com algum sistema de orquestração de microsserviços disponível para o Docker, em nível de aplicação.
%
Nesse sentido, a configuração inicial de cada instância foi feita de forma automatizada, com um \textit{script} na linguagem \textit{Bash} o qual configura o ambiente com a plataforma \textit{Docker}~\footnote{Docker: \url{https://www.docker.com/}}.
%
A Tabela~\ref{tab:docker_versoes} enumera as versões do Docker instaladas na máquina e o orquestrador escolhido para operação.

\begin{table}[htb!]
    \centering
    \caption{Orquestradores utilizados no teste.}
    \label{tab:docker_versoes}
    \begin{tabular}{|l|l|l|l|}
    \hline
        Nome                    & Docker Engine & Docker Compose & Orquestrador   \\ \hline
        \textit{client\_*}      & 18.09         & 3.0            & Docker Swarm   \\ \hline
        \textit{game\_service}  & 18.09         & 3.0            & Docker Swarm   \\ \hline
        \textit{game\_database} & 18.09         & 3.0            & Docker Compose \\ \hline
        \textit{data\_analisys} & 18.09         & 3.0            & Docker Compose \\ \hline
    \end{tabular}

    Fonte: O próprio autor.
\end{table}

Em específico neste projeto, foram utilizados os orquestradores Docker Swarm e Docker Compose (Tabela~\ref{tab:docker_versoes}).
%
Estes dois orquestradores facilitam, respectivamente, a implantação de arquiteturas complexas sem relacionamento com o disco rígido e o controle de volumes para armazenamento temporário de dados.
%
Dessa forma, os serviços implantados nas instâncias \textit{game\_service} e \textit{client\_*} são gerenciados pelo Docker Swarm, visto que ambos não necessitam de acesso a disco e podem ser escalados para mais de uma instância.
%
Por sua vez, os serviços restantes precisam de acesso a disco. 
%
Dessa forma, estes foram implantados utilizando o Docker Compose.


Em especial, sistema de coleta de métricas é executado na instância \textit{data\_analisys} e foi implantado utilizando Docker Compose.
%
Esta instância é uma peça fundamental para o sucesso do atual trabalho, haja visto que toda a captura de métricas é armazenada e processada nesta instância.
%
Assim, faz-se necessário detalhar o funcionamento deste sistema computacional.


\section{Sistema de coleta de informações de recursos}
\label{sec:informacoes}

O sistema de coleta de informações tem como principal objetivo receber requisições do estado da aplicação ou instância.
%
Em específico para esta aplicação, o sistema de métricas relacionará um montante (GBs, MBs, Tempo de Requisição) em relação ao tempo, formando gráficos os quais podem ser comparados entre sí dentro de um período.

Para esta solução, a pilha de monitoramento escolhida é o banco de dados para métricas Graphite~\footnote{Graphite DB: \url{https://graphiteapp.org/}} e o gestor web para visualização Grafana~\footnote{Grafana: \url{https://grafana.com/}}.
%
Estas soluções foram escolhidas por afinidade, facilidade de uso e por serem ferramentas de uso em ambientes reais para este objetivo.



Utilizando o Grafana, é possível verificar e comparar períodos diretamente por seu sistema web, durante a execução dos testes.
%
Isto permite maior flexibilidade e segurança da obtenção de dados, na qual são monitorados de forma facilitada pelo operador dos testes em seu painel de operações, como exibido na Figura~\ref{fig:grafana}.

O Grafana exibirá os dados armazenados no banco de dados Graphite.
%
Este banco de dados é específico para armazenamento de métricas.
%
Nesse sentido, este é capaz de otimizar a transferência de informações a qual são enviadas do serviço de jogo e do cliente.

Existem dois tipos de monitores o qual populam os dados automaticamente no sistema de monitoramento.
%
O monitor de recurso e monitor de tempo. 
%
O monitor de recurso é utilizado no \textit{game\_service} na qual envia métricas do consumo de recursos pela instância.
%
Além deste, o monitor de tempo é responsável por popular com o tempo de execução, do ponto de vista do cliente ao serviço (executado no \textit{game\_client}).

Os dados são analisados tanto nos gráficos padrões de monitoramento do grafana, quanto pós processados por outras ferramentas como o Gnuplot~\footnote{Gnuplot: \url{http://www.gnuplot.info/}}, na qual são alimentados pelos dados obtidos através da \ac{api} de render do Graphite.
%
Nesse sentido, também existe a flexibilidade de obter métricas para estudos estatísticos externos a pilha padrão do Graphite/Grafana.



\section{Arquitetura Rudy}
\label{sec:arc_rudy}

A arquitetura Rudy (Subseção \ref{rudy}), a primeira arquitetura desenvolvida, teve o seu funcionamento reduzido aos microsserviços básicos para o funcionamento do Gerente de Mundo.
%
Nesse sentido, os microsserviços implementados para esta arquitetura foram:

\begin{enumerate}
    \item Serviço de Jogo: Ou \textit{rudygh}.
    \item Gerenciador de Consultas: Ou \textit{rudydb}.
    \item Serviço de Autenticação: Ou \textit{rudya}.
    \item Serviço Web Dinâmico: Ou \textit{rudyweb}.
\end{enumerate}



Além destes microsserviços, a arquitetura utiliza os serviços PostgreSQL e Redis, ambas de código aberto.
%
Tais serviços são utilizados respectivamente como banco de dados permanente e banco de dados em memória cache para autenticação.
%
Este método de autenticação foi replicado para as demais arquiteturas.

Em relação aos protocolos utilizados na arquitetura Rudy, esta arquitetura utiliza serviços com o protocolos \ac{rpc} e \ac{http}.
%
A relação detalhada é exibida na Tabela~\ref{tab:protocolos_rudy}.



\begin{table}[htb!]
    \centering
    \caption{Protocolos dos microsserviços da arquitetura Rudy.}
    \label{tab:protocolos_rudy}
    \begin{tabular}{|l|l|l|l|}
    \hline
    Microsserviço & Linguagem de Programação    & Porta & Protocolo \\ \hline
    rudygh        & Golang 1.11 / RPC Nativo    & 3000  & TCP       \\ \hline
    rudydb        & Golang 1.11 / Gin Framework & 3000  & HTTP      \\ \hline
    rudya         & Golang 1.11 / RPC Nativo    & 3000  & TCP       \\ \hline
    rudyweb       & Golang 1.11 / Gin Framework & 3000  & HTTP      \\ \hline
    \end{tabular}
    
    Fonte: O próprio autor.
\end{table}
%ccm justificar a escolha


Além dos protocolos utilizados, a Tabela~\ref{tab:protocolos_rudy} relaciona a linguagem / tecnologia utilizados para escrever o serviço.
%
Tanto nos microsserviços da arquitetura Rudy, quanto aos demais microsserviços implementados, foram escritos na linguagem Go, evitando a repetição de códigos compartilhados entre eles.
%
Ambos os serviços compartilham dos mesmos modelos de padrão \ac{mvc} tanto para as aplicações \ac{rpc} e \ac{http}.

Para o desenvolvimento dos microsserviços da arquitetura Rudy, foram utilizados os seguintes pacotes externos da linguagem:

\begin{itemize}
    \item Gin: Framework focado em desenvolvimentos de \ac{api} para web escrito em Golang.
    \item Redis: Pacote de conexão sobre \ac{tcp} ou \ac{udp} em um serviço Redis.
    \item Protofub: Pacote que implementa serialização de dados estruturados de modo mínimo. É utilizado para minimizar custo de chamadas \ac{rpc} em Go.
    \item Gorm: Golang \ac{orm} que permite a conexão com o banco de dados Postgres sem utilizar \ac{sql}.
    \item Graphite: Pacote que permite a conexão com o servidor de logs Graphite para enviar métricas.
    \item Gorequest: Pacote para estruturar requisições Web utilizado para comunicação interna entre serviços Web utilizando assinatura \ac{jwt}.
    \item Testify: Suíte de testes para manter o funcionamento íntegro durante a implementação da aplicação. Em específico, a aplicação possúi 90\% de convergência de código, a qual garante a integridade de futuras alterações.
\end{itemize}

A pilha de desenvolvimento utilizando Golang 1.11 deve-se pela simplicidade de escrita de código e eficiência (linguagem compilada e tipada).
%
Além de sua eficiência computacional, existe uma grande comunidade que apoia o desenvolvimento de microsserviços utilizando Golang, a qual contribui continuamente para desenvolver bibliotecas para suas soluções.
%
Nesse sentido, todas as bibliotecas utilizadas são distribuídas no modelo \textit{Open Source}, pelas licenças \textit{MIT}, \textit{BSD} e \textit{GPLv3}.
%
Estas mesmas bibliotecas são utilizadas nas demais arquiteturas.
